##  理论

#### 存储结构

```
1. hash。以快速的精确查询，但是不支持范围查询，适合kv结构
2. 有序数组。增删数据成本很高，适合存放静态数据
3. 二叉树。支持范围查询，但树很高，硬盘寻址查询很慢
4. B树。比二叉树矮，B树的一个节点可以存储多个元素
5. B+树。B树的升级版，把非叶子节点冗余一下，叶子节点之间用指针相连，提高范围查找的效率
```

#### 索引使用原则

```
1. 最左匹配原则。联合索引有多个列组成，根据列的排列顺序依次做相等匹配，遇到范围查找时即停止匹配
2. 索引覆盖。不需要回表，查询结果已经在索引结构中
3.ICP索引下推。通过部分WHERE条件能使用联合索引中的字段，MySQL Server 会把这部分筛选功能下推到引擎层
```

#### 隔离级别（isolation_level）

隔离级别的实现，是基于数据库里面会创建的一个视图，访问的时候以视图的逻辑结果为准。

- 可重复读( repeatable read )，一个事务执行过程中看到的数据，总是跟事务启动时看到的数据是一致的。会在 **每个事务开始的时候** 创建一致性视图，整个事务存在期间都用这个视图
- 读未提交( read uncommitted )，一个事务还没提交时，它做的变更就能被别的事务看到；没有一致性视图，只读取最新版本的数据
- 读提交( read committed )，一个事务提交之后，它做的变更才会被其他事务看到。会在 **每个SQL开始执行的时候** 创建一致性视图
- 串行化( serializable )，顾名思义是对于同一行记录会加锁，后访问的事务必须等前一个事务执行完成。

在“RR”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“RC”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。

#### 当前读与快照读

- 快照读(snapshot read)：普通的的select操作
- 当前读(current read)：
  1. select ... lock in share mode
  2. select ... for update
  3. insert、update、delete

#### MVCC多版本控制

MVCC全称是： **multi version concurrency control**，多版本并发控制， 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入MVCC之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度

InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的；InnoDB 的行数据有多个版本，因为每个数据版本有自己的 row trx_id，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性。

- 对于RR，普通查询只承认在事务启动前就已经提交完成的数据；
- 对于RC，普通查询只承认在语句启动前就已经提交完成的数据； 
- **当前读**总是读取最新版本的数据。

在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。

#### Log

##### redolog

redolog是**存储引擎层**的日志，又称重做日志文件，在事务执行开始时就写入redolog。**更新**语句时，引擎会把更新记录写到日志内存缓冲区 redo log buffer ，在合适的时间落盘写入redolog日志中：

1. mysql正常关闭时
2. 后台线程每隔一段时间定时写入到redolog文件，默认1s刷一次
3. buffer写入量超过buffer内存的一半的时候，触发刷盘
4. 当事务提交时，根据配置的参数 innodb_flush_log_at_trx_commit 来决定是否刷盘（1刷盘0不刷盘2刷新到cache）

在日志记录到缓冲区或者log之后，或在内存中update这条记录，并在空闲时按照设定的**策略**更新到磁盘，这就是`WAL`即`Write Ahead logging`技术，他的关键点是先写日志，再写磁盘。

redo log日志的大小是固定的，即记录满了以后就从头循环写。如果redo log已经满了，这个时候数据库停止进行数据库更新语句的执行，转而进行redo log刷盘。

##### binlog

binlog是属于MySQL Server层面的，又称为归档日志，属于逻辑日志，是以二进制的形式记录的是这个语句的原始逻辑，依靠binlog是没有`crash-safe`能力的，binlog主要用于主从复制和数据库的基于时间点的还原。

结合前面介绍的 redo 相关的基础知识，下面来看下 MySQL 究竟是如何来保证数据不丢失的：

```
update T set c=c+1 where ID=2;
```

1. 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存（Buffer Pool 中的缓存页）中，就直接返回给执行器;否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到 新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态(处于prepare状态之后要写入磁盘中,但是redo log的commit得标识为没有commit)。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交(commit)状态，更新完成。
6. 接着根据 innodb_flush_log_at_commit 参数的配置，决定是否将 redo log buffer 中的日志刷入到磁盘。

将 redo log 日志标记为 prepare 状态和 commit 状态，这种做法称之为**两阶段事务提交**，它能保证事务在提交后，数据不丢失。为什么呢？redo log 在进行数据重做时，只有读到了 commit 标识，才会认为这条 redo log 日志是完整的，才会进行数据重做，否则会认为这个 redo log 日志不完整，不会进行数据重做。要严格保证数据不丢失，必须得保证 innodb_flush_log_at_trx_commit 配置为 1（即事务提交时刷盘）。

通常我们说 MySQL 的“双 1”配置，指的就是 sync_binlog 和 innodb_flush_log_at_trx_commit 都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是 redo log(prepare 阶段)，一次是 binlog。

- 浅色框表示是在 InnoDB 存储引擎层执行的， 深色框表示是在server执行器中执行的

![tDCPEt.png](https://s1.ax1x.com/2020/06/04/tDCPEt.md.png)

##### undolog

undo log主要记录的是数据的逻辑变化，undo是一种逻辑日志，有两个作用：

- **事务的回滚**。在数据修改的时候，不仅记录了redo的物理日志，还记录了相对应的undo逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录，当事务需要执行rollback时，可以使用 undo 日志来实现回滚操作，由此保证事务的一致性。
- **多版本控制(MVCC)**。当读取的某一行被其他事务锁定时，它可以从undo log中分析出该行记录以前的数据是什么，从而提供该行版本信息，让用户实现一致性读。当其他事务修改多次修改行时，一致性读需要顺着 undo 链找到满足其可见性的记录。当版本链很长时，通常可以认为这是个比较耗时的操作。

undo会在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。就是当系统里没有比这个回滚日志更早的 read-view 的时候。

#### 锁

行锁根据互斥的纬度可以分为：
    1、共享锁（S锁）：当读取当一行记录时为了防止别人修改则需要添加S锁。
    2、排他锁（X锁）：当修改一行记录时为了防止别人同时进行修改则需要添加X锁。

根据锁定的范围可以分为：

- Record Lock：单个行记录上的锁。
- Gap Lock：间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。
- Next-Key Lock：1+2，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。

​    1、间隙锁：间隙锁锁定范围是索引记录之间的间隙或者第一个或最后一个索引记录之前的间隙(指虚拟最大记录)
​    2、记录锁：MySQL中记录锁都是添加在索引上，即使表上没有索引也会在隐藏的聚集索引上添加记录锁。
​    3、next-key lock：Next-Key Locks是Record Locks与Gap Locks间隙锁的组合，也就是索引记录本身加上之前的间隙。间隙锁防止了保证RR级别下不出现幻读现象会，防止同一个事务内得 到的结果不一致。
​    4、插入意向锁：插入意向锁定是在行插入之前由INSERT操作设置的一种间隙锁。这个锁表示插入的意图，即插入相同索引间隙的多个事务如果不插入间隙内的相同位置则不需要等待彼此，插入意向锁是一种特殊的GAP LOCK。

InnoDB对于行的查询都是采用了Next-Key Lock的算法，锁定的不是单个值，而是一个范围。但是，当查询的索引含有唯一属性的时候，Next-Key Lock 会进行优化，将其降级为Record Lock，即仅锁住索引本身，不是范围

